# Application Context

## System Architecture
- Web-based application running in a containerized environment
- Frontend: HTML/CSS/JS with Alpine.js for reactivity
- Backend: Python with FastAPI
- Communication via RESTful API endpoints
- File-based persistence for contexts and tasks

## Implementation Guidelines

### API and Backend Guidelines
- DO NOT create alternate implementations of existing functionality
- Use the established TaskScheduler class for all task operations
- Be extremely conservative when modifying existing functionality
- Always follow existing API patterns and conventions
- Assume all code outside of mounted volumes will be lost on container restart
- NEVER manually register API handlers - the application uses an automatic discovery system
- API handlers in the "python/api" directory are automatically loaded and registered
- API endpoints are derived from Python file names (minus the .py extension)
- Always create the API handler file in the correct location before referencing it in frontend code

### UI and CSS Guidelines
- NEVER modify or reuse existing CSS classes if it would mean changing them
- ALWAYS create new, distinctly named classes with appropriate prefixes
- Follow component-specific prefix conventions (e.g., `scheduler-` for scheduler components)
- Keep CSS scoped to the specific component being modified
- Study existing UI patterns but create new classes rather than modifying existing ones

### Alpine.js Integration Guidelines
- ALWAYS match property names exactly between HTML component definitions and JavaScript code
- When accessing Alpine.js component data, verify the property names in the HTML first
- Alpine.js components use x-data to define their properties (e.g., `x-data="{ contexts: [], selected: '' }"`)
- When updating component data from JavaScript, use the exact property names from x-data
- Use Alpine.$data(element) to safely access component data from vanilla JavaScript
- Remember that typos or mismatches in property names will silently fail - no error will be thrown
- UI components won't display data if the property names don't match exactly

## Task Scheduler System
The task scheduler allows users to create and run automated tasks in the system. Tasks can be scheduled to run on a cron schedule or triggered manually.

### Key Components
- **Task Management**: Creates, updates, deletes, and runs tasks
- **Context System**: Maintains chat contexts for each task
- **Persistence Layer**: Saves and loads task states and histories
- **UI Integration**: Allows users to interact with tasks via the web interface

### Implementation Details
- Tasks are stored in memory with JSON serialization for persistence
- Chat contexts are saved to a single folder location for all contexts
- `CHATS_FOLDER` contains both regular chat contexts and task contexts
- Task contexts are identified by checking if their UUID matches a task in the scheduler
- Reset functionality preserves task association while clearing history

### UI Implementation
- Scheduler tab implemented in settings modal with full task management capabilities
- Tab selection mechanism fixed to work consistently on initial load and subsequent clicks
- Two-view implementation: simplified view in left panel and detailed view in settings modal
- Consistent event handling with proper Alpine.js reactivity
- Tab state preserved via localStorage for user convenience

### API Endpoints
- **scheduler_tick.py**: Periodic endpoint for checking and running due tasks (cron-triggered)
- **scheduler_task_run.py**: API for manually running a specific task (user-triggered)
- **scheduler_tasks_list.py**: Lists all tasks with their metadata
- **scheduler_task_create.py**: Creates new scheduled or ad-hoc tasks
- **scheduler_task_delete.py**: Deletes tasks and their associated contexts
- **scheduler_task_update.py**: Updates existing task properties

### Important Distinction
- **scheduler_tick**: Only for automatic cron-based execution, triggered by system cron
- **scheduler_task_run**: Only for manual task execution, triggered by user action

### Upcoming Settings Modal Implementation
- Complete settings modal interface for task management is planned
- Will include comprehensive task creation/editing form
- Will feature task list with sorting/filtering capabilities
- Will provide visual schedule builder for cron expressions
- Will integrate with existing settings modal infrastructure
- Will leverage existing backend API endpoints for task operations
- Client-side validation will mirror server-side validation rules

## Context Management System
The context management system handles the state and history of chats and tasks.

### Important Considerations
- Contexts are identified as task contexts if their UUID matches a task in the scheduler
- Reset operation must maintain task association while clearing history
- Context files must be fully removed before reset to prevent data persistence issues
- Task contexts are stored in the same location as regular chat contexts

## Critical Warning Flags
- Container persistence only works through mounted volumes
- All localStorage keys must use camelCase
- Component naming follows strict patterns
- Task contexts require special handling
- Context reset must preserve task association
- Always clean up task resources properly

## File Organization
- Python API handlers in `python/api/`
- Helper modules in `python/helpers/`
- Frontend assets in `webui/`
- All contexts (chats and tasks) in `tmp/chats/`

This context document is part of a three-file system along with `.warning-flags` and `.cursor/notebooks/ai_assistant_scratchpad.md`.

# Agent Zero Project Context

## Core Architecture
- **Backend:** Python Flask server (`run_ui.py`) using `make_server`.
- **Frontend:** Single Page Application (`webui/index.html`) using Alpine.js for reactivity.
- **Communication:** Frontend polls (`/poll`) backend for state updates. User actions trigger specific backend API endpoints.
- **Asynchronicity:** Agent LLM interactions run in background threads (`DeferredTask`).

## Key Backend Files & Paths
- **Entry Point:** `run_ui.py`
- **API Handlers:** `python/api/*.py` (e.g., `poll.py`, `chat.py`, `settings_get.py`, `scheduler_tasks_list.py`)
- **API Base:** `python/helpers/api.py` (`ApiHandler`)
- **Core Agent Logic:** `agent.py` (`Agent`, `AgentContext`)
- **Configuration:** `initialize.py`, `python/helpers/settings.py`
- **Persistence:**
    - Chats/Contexts: `python/helpers/persist_chat.py` -> `tmp/chats/{ctxid}/chat.json`
    - Chat Names/Metadata: `python/helpers/chat_names.py` -> `tmp/chat_names.json`, `tmp/chat_metadata.json`
    - Task Scheduler: `python/helpers/task_scheduler.py` -> `memory/scheduler/tasks.json`
    - Settings: `python/helpers/settings.py` -> `tmp/settings.json`, `.env`
- **History:** `python/helpers/history.py`
- **Task Scheduling:** `python/helpers/task_scheduler.py`
- **Extensions:** `python/extensions/*/*.py`

## Key Frontend Files & Paths
- **Main Page:** `webui/index.html`
- **Core JS:** `webui/index.js` (polling, UI updates, context switching)
- **Component JS:** `webui/js/*.js` (e.g., `settings.js`, `scheduler.js`, `modal.js`)
- **Core CSS:** `webui/index.css`
- **Component CSS:** `webui/css/*.css` (e.g., `settings.css`, `modals.css`)

## Core Data Structures
- **Backend:**
    - `AgentContext` (in `agent.py`): Holds state for a chat/task (config, log, agents, history, flags like reasoning/planning). Persisted.
    - `AgentConfig`, `ModelConfig` (in `agent.py`, `initialize.py`): Configuration objects.
    - `Settings` (TypedDict in `settings.py`): Structure for application settings.
    - `ScheduledTask`, `AdHocTask` (Pydantic models in `task_scheduler.py`): Task definitions. Persisted.
- **Frontend:**
    - Alpine.js Stores: `$store.root` (`index.js`, `settings.js`) holds global UI state (activeTab, reasoning/planning flags).
    - Alpine.js Component Data (`x-data`): Used extensively for component-specific state (e.g., `settingsModalProxy`, `schedulerSettings`, chat/task lists in `index.html`/`index.js`).
    - Polling Response (from `/poll`): Dictionary containing `contexts` (chats), `tasks`, `logs` for current context, global flags.

## State Management Summary
- **Backend:** Source of truth. State stored in `AgentContext` objects (in memory) and persisted to JSON files.
- **Frontend:** Receives state updates primarily via `/poll`. Manages UI state reactively using Alpine.js stores and component data. Uses `localStorage` for persisting UI preferences (e.g., active tabs, dark mode).

## Key API Endpoints
- `/poll`: (POST) Fetches current state, logs, context lists for UI updates.
- `/chat`: (POST) Sends user message to the agent, triggers background processing.
- `/chat_reset`: (POST) Resets the current agent context.
- `/chat_rename`: (POST) Renames a chat/task context.
- `/chat_remove`: (POST) Deletes a chat/task context and associated files.
- `/settings_get`: (POST) Retrieves current application settings for the UI.
- `/settings_set`: (POST) Saves updated application settings from the UI.
- `/scheduler_tasks_list`: (POST) Lists all defined tasks.
- `/scheduler_task_create`: (POST) Creates a new scheduled or ad-hoc task.
- `/scheduler_task_update`: (POST) Updates an existing task.
- `/scheduler_task_delete`: (POST) Deletes a task.
- `/scheduler_task_run`: (POST) Manually triggers a task run.
- `/scheduler_tick`: (POST, Loopback only) Checks for due scheduled tasks (likely triggered externally).
- `/files_list`, `/file_download`, `/file_delete`, `/file_upload`: (POST) File browser operations.
- `/history_get`: (POST) Retrieves context history for the history modal.
- `/tasklist_get`, `/tasklist_save`: (POST) Get/save task list for the notepad modal.
- `/notepad_get`, `/notepad_save`: (POST) Get/save notepad content for the notepad modal.

## Coding Conventions Observed
- **Python:** Generally follows PEP 8. Uses type hints. Pydantic for task models. Flask for web server. `ApiHandler` pattern for endpoints.
- **JavaScript:** Uses Alpine.js extensively for frontend logic and reactivity. Vanilla JS for core logic (`index.js`). Uses `async/await` for API calls.
- **CSS:** Uses CSS variables for theming. Prefixes component-specific classes (e.g., `scheduler-`, `settings-`). Includes responsive design media queries.
